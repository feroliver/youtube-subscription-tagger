import logging
from flask import Flask, render_template, request, jsonify, redirect, url_for, session, make_response
import database as db
import youtube_api as yt
import os
import json

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

app = Flask(__name__)
# Required for session management (used implicitly by OAuth flow sometimes, good practice)
# In a production app, use a strong, randomly generated secret key
app.secret_key = os.environ.get('FLASK_SECRET_KEY', 'dev-secret-key-replace-in-prod')

# --- Authentication Check ---
# We rely on youtube_api.get_authenticated_service() to handle the flow.
# A simple check if the token file exists can speed up initial load slightly,
# but the robust check happens when the service is requested.

def check_authentication():
    """Checks if the user appears to be authenticated (token exists)."""
    return os.path.exists(yt.TOKEN_PICKLE_FILE)

# --- Routes ---

@app.route('/')
def index():
    """Main page: Displays channels and filters."""
    if not check_authentication():
        # If no token, attempt to authenticate first. get_authenticated_service handles the flow.
        logging.info("No token file found, attempting authentication...")
        service = yt.get_authenticated_service()
        if not service:
            # Authentication failed or was cancelled by user
            return "Authentication required. Please ensure you have 'client_secrets.json' and run the app again to authorize.", 401
        # If auth succeeded, proceed to fetch/display data
        logging.info("Authentication successful, proceeding to load data.")

    # Fetch channels from DB
    channels = db.get_all_channels()
    unique_tags = db.get_unique_tags()

    # Optional: If DB is empty, trigger initial fetch from YouTube API
    if not channels:
        logging.info("Database is empty. Fetching subscriptions from YouTube API...")
        service = yt.get_authenticated_service() # Ensure we have a service object
        if service:
            yt_subscriptions = yt.get_all_subscriptions(service)
            if yt_subscriptions:
                logging.info(f"Adding {len(yt_subscriptions)} channels to the database.")
                for sub in yt_subscriptions:
                    db.add_or_update_channel(
                        sub['channel_id'],
                        sub['title'],
                        sub['thumbnail_url']
                    )
                # Re-fetch from DB after adding
                channels = db.get_all_channels()
                unique_tags = db.get_unique_tags()
            else:
                 logging.warning("Fetched no subscriptions from YouTube API.")
        else:
             logging.error("Could not get authenticated YouTube service to perform initial fetch.")
             # Handle error case: maybe show an error message on the page
             return "Error: Could not connect to YouTube API after authentication.", 500


    return render_template('index.html', channels=channels, unique_tags=unique_tags)

@app.route('/refresh_from_youtube', methods=['POST'])
def refresh_from_youtube():
    """Fetches latest subscriptions from YouTube and updates the database."""
    logging.info("Attempting to refresh subscriptions from YouTube API...")
    service = yt.get_authenticated_service()
    if not service:
        return jsonify({"success": False, "message": "Authentication failed or required."}), 401

    yt_subscriptions = yt.get_all_subscriptions(service)
    if yt_subscriptions is None: # Check if fetch failed
         return jsonify({"success": False, "message": "Failed to fetch subscriptions from YouTube API."}), 500

    logging.info(f"Fetched {len(yt_subscriptions)} channels from YouTube. Updating database...")
    # Add/update channels in DB (preserves existing tags)
    for sub in yt_subscriptions:
        db.add_or_update_channel(
            sub['channel_id'],
            sub['title'],
            sub['thumbnail_url']
        )
    logging.info("Database update complete after refresh.")
    # Consider removing channels from DB that are no longer in yt_subscriptions? (More complex)

    # Return the updated list of channels and tags for the frontend
    updated_channels = db.get_all_channels()
    updated_tags = db.get_unique_tags()
    return jsonify({
        "success": True,
        "message": f"Refreshed {len(yt_subscriptions)} channels from YouTube.",
        "channels": updated_channels,
        "unique_tags": updated_tags
        })


@app.route('/api/tags/<channel_id>', methods=['POST'])
def update_tags(channel_id):
    """API endpoint to update tags for a given channel."""
    data = request.get_json()
    if not data or 'tags' not in data:
        return jsonify({"success": False, "message": "Missing 'tags' in request data."}), 400

    tags_string = data['tags']
    # Convert comma-separated string to a list of cleaned tags
    tags_list = [tag.strip() for tag in tags_string.split(',') if tag.strip()]

    success = db.update_channel_tags(channel_id, tags_list)

    if success:
        # Return updated tags list and unique tags for frontend update
        updated_channel_data = next((c for c in db.get_all_channels() if c['channel_id'] == channel_id), None)
        current_tags = updated_channel_data.get('tags', []) if updated_channel_data else []
        unique_tags = db.get_unique_tags()
        return jsonify({
            "success": True,
            "channel_id": channel_id,
            "tags": current_tags, # Send back the processed list
            "unique_tags": unique_tags
        })
    else:
        return jsonify({"success": False, "message": "Failed to update tags in database."}), 500

# Note: We are doing client-side filtering in this version based on the JS,
# so a server-side filtering endpoint might not be strictly necessary unless
# the channel list is very large. If needed, it would look like this:
# @app.route('/api/channels', methods=['GET'])
# def get_filtered_channels():
#     """ API endpoint to get channels, optionally filtered by tag """
#     tag_filter = request.args.get('tag')
#     if tag_filter:
#         # Modify get_channels_by_tag in database.py if needed
#         channels = db.get_channels_by_tag(tag_filter)
#     else:
#         channels = db.get_all_channels()
#     return jsonify(channels)


if __name__ == '__main__':
    # Ensure DB is created on first run if needed
    db.init_db()
    # Note: Setting debug=True can be helpful but disable in production
    # Use host='0.0.0.0' to make it accessible on your network
    app.run(debug=True, port=5000)
